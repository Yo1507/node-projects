{
  "_from": "yargs@4.7.1",
  "_id": "yargs@4.7.1",
  "_inBundle": false,
  "_integrity": "sha1-5gQyZYozh/8mnAKOrN5KUS5Djf8=",
  "_location": "/yargs",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "yargs",
    "fetchSpec": "4.7.1",
    "name": "yargs",
    "raw": "yargs@4.7.1",
    "rawSpec": "4.7.1",
    "registry": true,
    "saveSpec": null,
    "type": "version"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/yargs/-/yargs-4.7.1.tgz",
  "_shasum": "e60432658a3387ff269c028eacde4a512e438dff",
  "_shrinkwrap": null,
  "_spec": "yargs@4.7.1",
  "_where": "C:\\Dev\\notes-node",
  "bugs": {
    "url": "https://github.com/yargs/yargs/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "camelcase": "^3.0.0",
    "cliui": "^3.2.0",
    "decamelize": "^1.1.1",
    "lodash.assign": "^4.0.3",
    "os-locale": "^1.4.0",
    "pkg-conf": "^1.1.2",
    "read-pkg-up": "^1.0.1",
    "require-main-filename": "^1.0.1",
    "set-blocking": "^1.0.0",
    "string-width": "^1.0.1",
    "window-size": "^0.2.0",
    "y18n": "^3.2.1",
    "yargs-parser": "^2.4.0"
  },
  "deprecated": false,
  "description": "yargs the modern, pirate-themed, successor to optimist.",
  "devDependencies": {
    "chai": "^3.4.1",
    "chalk": "^1.1.3",
    "coveralls": "^2.11.9",
    "cpr": "^1.0.0",
    "cross-spawn-async": "^2.2.1",
    "es6-promise": "^3.0.2",
    "hashish": "0.0.4",
    "mocha": "^2.4.5",
    "nyc": "^6.4.2",
    "rimraf": "^2.5.0",
    "standard": "^7.0.0",
    "standard-version": "^2.2.1",
    "which": "^1.1.2"
  },
  "engine": {
    "node": ">=0.10"
  },
  "files": [
    "LICENSE",
    "completion.sh.hbs",
    "index.js",
    "lib",
    "locales",
    "yargs.js"
  ],
  "homepage": "http://yargs.js.org/",
  "keywords": [
    "args",
    "argument",
    "cli",
    "command",
    "option",
    "parser",
    "parsing"
  ],
  "license": "MIT",
  "main": "./index.js",
  "name": "yargs",
  "optionalDependencies": {},
  "readme": "yargs\r\n========\r\n\r\nYargs be a node.js library fer hearties tryin' ter parse optstrings.\r\n\r\nWith yargs, ye be havin' a map that leads straight to yer treasure! Treasure of course, being a simple option hash.\r\n\r\n[![Build Status][travis-image]][travis-url]\r\n[![Dependency Status][gemnasium-image]][gemnasium-url]\r\n[![Coverage Status][coveralls-image]][coveralls-url]\r\n[![NPM version][npm-image]][npm-url]\r\n[![Windows Tests][windows-image]][windows-url]\r\n[![js-standard-style][standard-image]][standard-url]\r\n[![standard-version][standard-version-image]][standard-version-url]\r\n\r\n> Yargs is the official successor to optimist. Please feel free to submit issues and pull requests. If you'd like to contribute and don't know where to start, have a look at [the issue list](https://github.com/yargs/yargs/issues) :)\r\n\r\nexamples\r\n========\r\n\r\nWith yargs, the options be just a hash!\r\n-------------------------------------------------------------------\r\n\r\nplunder.js:\r\n\r\n````javascript\r\n#!/usr/bin/env node\r\nvar argv = require('yargs').argv;\r\n\r\nif (argv.ships > 3 && argv.distance < 53.5) {\r\n    console.log('Plunder more riffiwobbles!');\r\n} else {\r\n    console.log('Retreat from the xupptumblers!');\r\n}\r\n````\r\n\r\n***\r\n\r\n    $ ./plunder.js --ships=4 --distance=22\r\n    Plunder more riffiwobbles!\r\n\r\n    $ ./plunder.js --ships 12 --distance 98.7\r\n    Retreat from the xupptumblers!\r\n\r\n![Joe was one optimistic pirate.](http://i.imgur.com/4WFGVJ9.png)\r\n\r\nBut don't walk the plank just yet! There be more! You can do short options:\r\n-------------------------------------------------\r\n\r\nshort.js:\r\n\r\n````javascript\r\n#!/usr/bin/env node\r\nvar argv = require('yargs').argv;\r\nconsole.log('(%d,%d)', argv.x, argv.y);\r\n````\r\n\r\n***\r\n\r\n    $ ./short.js -x 10 -y 21\r\n    (10,21)\r\n\r\nAnd booleans, both long, short, and even grouped:\r\n----------------------------------\r\n\r\nbool.js:\r\n\r\n````javascript\r\n#!/usr/bin/env node\r\nvar argv = require('yargs').argv;\r\n\r\nif (argv.s) {\r\n    process.stdout.write(argv.fr ? 'Le perroquet dit: ' : 'The parrot says: ');\r\n}\r\nconsole.log(\r\n    (argv.fr ? 'couac' : 'squawk') + (argv.p ? '!' : '')\r\n);\r\n````\r\n\r\n***\r\n\r\n    $ ./bool.js -s\r\n    The parrot says: squawk\r\n\r\n    $ ./bool.js -sp\r\n    The parrot says: squawk!\r\n\r\n    $ ./bool.js -sp --fr\r\n    Le perroquet dit: couac!\r\n\r\nAnd non-hyphenated options too! Just use `argv._`!\r\n-------------------------------------------------\r\n\r\nnonopt.js:\r\n\r\n````javascript\r\n#!/usr/bin/env node\r\nvar argv = require('yargs').argv;\r\nconsole.log('(%d,%d)', argv.x, argv.y);\r\nconsole.log(argv._);\r\n````\r\n\r\n***\r\n\r\n    $ ./nonopt.js -x 6.82 -y 3.35 rum\r\n    (6.82,3.35)\r\n    [ 'rum' ]\r\n\r\n    $ ./nonopt.js \"me hearties\" -x 0.54 yo -y 1.12 ho\r\n    (0.54,1.12)\r\n    [ 'me hearties', 'yo', 'ho' ]\r\n\r\nYargs even counts your booleans!\r\n----------------------------------------------------------------------\r\n\r\ncount.js:\r\n\r\n````javascript\r\n#!/usr/bin/env node\r\nvar argv = require('yargs')\r\n    .count('verbose')\r\n    .alias('v', 'verbose')\r\n    .argv;\r\n\r\nVERBOSE_LEVEL = argv.verbose;\r\n\r\nfunction WARN()  { VERBOSE_LEVEL >= 0 && console.log.apply(console, arguments); }\r\nfunction INFO()  { VERBOSE_LEVEL >= 1 && console.log.apply(console, arguments); }\r\nfunction DEBUG() { VERBOSE_LEVEL >= 2 && console.log.apply(console, arguments); }\r\n\r\nWARN(\"Showing only important stuff\");\r\nINFO(\"Showing semi-important stuff too\");\r\nDEBUG(\"Extra chatty mode\");\r\n````\r\n\r\n***\r\n    $ node count.js\r\n    Showing only important stuff\r\n\r\n    $ node count.js -v\r\n    Showing only important stuff\r\n    Showing semi-important stuff too\r\n\r\n    $ node count.js -vv\r\n    Showing only important stuff\r\n    Showing semi-important stuff too\r\n    Extra chatty mode\r\n\r\n    $ node count.js -v --verbose\r\n    Showing only important stuff\r\n    Showing semi-important stuff too\r\n    Extra chatty mode\r\n\r\nTell users how to use yer options and make demands.\r\n-------------------------------------------------\r\n\r\narea.js:\r\n\r\n````javascript\r\n#!/usr/bin/env node\r\nvar argv = require('yargs')\r\n    .usage('Usage: $0 -w [num] -h [num]')\r\n    .demand(['w','h'])\r\n    .argv;\r\n\r\nconsole.log(\"The area is:\", argv.w * argv.h);\r\n````\r\n\r\n***\r\n\r\n    $ ./area.js -w 55 -h 11\r\n    The area is: 605\r\n\r\n    $ node ./area.js -w 4.91 -w 2.51\r\n    Usage: area.js -w [num] -h [num]\r\n\r\n    Options:\r\n      -w  [required]\r\n      -h  [required]\r\n\r\n    Missing required arguments: h\r\n\r\nAfter yer demands have been met, demand more! Ask for non-hyphenated arguments!\r\n-----------------------------------------\r\n\r\ndemand_count.js:\r\n\r\n````javascript\r\n#!/usr/bin/env node\r\nvar argv = require('yargs')\r\n    .demand(2)\r\n    .argv;\r\nconsole.dir(argv);\r\n````\r\n\r\n***\r\n\r\n\t$ ./demand_count.js a\r\n\r\n\tNot enough non-option arguments: got 1, need at least 2\r\n\r\n\t$ ./demand_count.js a b\r\n\t{ _: [ 'a', 'b' ], '$0': 'demand_count.js' }\r\n\r\n\t$ ./demand_count.js a b c\r\n\t{ _: [ 'a', 'b', 'c' ], '$0': 'demand_count.js' }\r\n\r\nEVEN MORE SHIVER ME TIMBERS!\r\n------------------\r\n\r\ndefault_singles.js:\r\n\r\n````javascript\r\n#!/usr/bin/env node\r\nvar argv = require('yargs')\r\n    .default('x', 10)\r\n    .default('y', 10)\r\n    .argv\r\n;\r\nconsole.log(argv.x + argv.y);\r\n````\r\n\r\n***\r\n\r\n    $ ./default_singles.js -x 5\r\n    15\r\n\r\ndefault_hash.js:\r\n\r\n````javascript\r\n#!/usr/bin/env node\r\nvar argv = require('yargs')\r\n    .default({ x : 10, y : 10 })\r\n    .argv\r\n;\r\nconsole.log(argv.x + argv.y);\r\n````\r\n\r\n***\r\n\r\n    $ ./default_hash.js -y 7\r\n    17\r\n\r\nAnd if you really want to get all descriptive about it...\r\n---------------------------------------------------------\r\n\r\nboolean_single.js:\r\n\r\n````javascript\r\n#!/usr/bin/env node\r\nvar argv = require('yargs')\r\n    .boolean('v')\r\n    .argv\r\n;\r\nconsole.dir(argv.v);\r\nconsole.dir(argv._);\r\n````\r\n\r\n***\r\n\r\n    $ ./boolean_single.js -v \"me hearties\" yo ho\r\n    true\r\n    [ 'me hearties', 'yo', 'ho' ]\r\n\r\n\r\nboolean_double.js:\r\n\r\n````javascript\r\n#!/usr/bin/env node\r\nvar argv = require('yargs')\r\n    .boolean(['x','y','z'])\r\n    .argv\r\n;\r\nconsole.dir([ argv.x, argv.y, argv.z ]);\r\nconsole.dir(argv._);\r\n````\r\n\r\n***\r\n\r\n    $ ./boolean_double.js -x -z one two three\r\n    [ true, false, true ]\r\n    [ 'one', 'two', 'three' ]\r\n\r\nYargs is here to help you...\r\n---------------------------\r\n\r\nYe can describe parameters fer help messages and set aliases. Yargs figures\r\nout how ter format a handy help string automatically.\r\n\r\nline_count.js:\r\n\r\n````javascript\r\n#!/usr/bin/env node\r\nvar argv = require('yargs')\r\n    .usage('Usage: $0 <command> [options]')\r\n    .command('count', 'Count the lines in a file')\r\n    .demand(1)\r\n    .example('$0 count -f foo.js', 'count the lines in the given file')\r\n    .demand('f')\r\n    .alias('f', 'file')\r\n    .nargs('f', 1)\r\n    .describe('f', 'Load a file')\r\n    .help('h')\r\n    .alias('h', 'help')\r\n    .epilog('copyright 2015')\r\n    .argv;\r\n\r\nvar fs = require('fs');\r\nvar s = fs.createReadStream(argv.file);\r\n\r\nvar lines = 0;\r\ns.on('data', function (buf) {\r\n    lines += buf.toString().match(/\\n/g).length;\r\n});\r\n\r\ns.on('end', function () {\r\n    console.log(lines);\r\n});\r\n````\r\n\r\n***\r\n    $ node line_count.js count\r\n    Usage: line_count.js <command> [options]\r\n\r\n    Commands:\r\n      count    Count the lines in a file\r\n\r\n    Options:\r\n      -f, --file  Load a file        [required]\r\n      -h, --help  Show help           [boolean]\r\n\r\n    Examples:\r\n      line_count.js count -f foo.js  count the lines in the given file\r\n\r\n    copyright 2015\r\n\r\n    Missing required arguments: f\r\n\r\n    $ node line_count.js count --file line_count.js\r\n    26\r\n\r\n    $ node line_count.js count -f line_count.js\r\n    26\r\n\r\nmethods\r\n=======\r\n\r\nBy itself,\r\n\r\n````javascript\r\nrequire('yargs').argv\r\n````\r\n\r\nwill use the `process.argv` array to construct the `argv` object.\r\n\r\nYou can pass in the `process.argv` yourself:\r\n\r\n````javascript\r\nrequire('yargs')([ '-x', '1', '-y', '2' ]).argv\r\n````\r\n\r\nor use `.parse()` to do the same thing:\r\n\r\n````javascript\r\nrequire('yargs').parse([ '-x', '1', '-y', '2' ])\r\n````\r\n\r\nThe rest of these methods below come in just before the terminating `.argv`.\r\n\r\n<a name=\"alias\"></a>.alias(key, alias)\r\n------------------\r\n\r\nSet key names as equivalent such that updates to a key will propagate to aliases\r\nand vice-versa.\r\n\r\nOptionally `.alias()` can take an object that maps keys to aliases.\r\nEach key of this object should be the canonical version of the option, and each\r\nvalue should be a string or an array of strings.\r\n\r\n.argv\r\n-----\r\n\r\nGet the arguments as a plain old object.\r\n\r\nArguments without a corresponding flag show up in the `argv._` array.\r\n\r\nThe script name or node command is available at `argv.$0` similarly to how `$0`\r\nworks in bash or perl.\r\n\r\nIf `yargs` is executed in an environment that embeds node and there's no script name (e.g.\r\n[Electron](http://electron.atom.io/) or [nw.js](http://nwjs.io/)), it will ignore the first parameter since it\r\nexpects it to be the script name. In order to override this behavior, use `.parse(process.argv.slice(1))`\r\ninstead of `.argv` and the first parameter won't be ignored.\r\n\r\n<a name=\"array\"></a>.array(key)\r\n----------\r\n\r\nTell the parser to interpret `key` as an array. If `.array('foo')` is set,\r\n`--foo foo bar` will be parsed as `['foo', 'bar']` rather than as `'foo'`.\r\n\r\n<a name=\"boolean\"></a>.boolean(key)\r\n-------------\r\n\r\nInterpret `key` as a boolean. If a non-flag option follows `key` in\r\n`process.argv`, that string won't get set as the value of `key`.\r\n\r\n`key` will default to `false`, unless a `default(key, undefined)` is\r\nexplicitly set.\r\n\r\nIf `key` is an array, interpret all the elements as booleans.\r\n\r\n.check(fn)\r\n----------\r\n\r\nCheck that certain conditions are met in the provided arguments.\r\n\r\n`fn` is called with two arguments, the parsed `argv` hash and an array of options and their aliases.\r\n\r\nIf `fn` throws or returns a non-truthy value, show the thrown error, usage information, and\r\nexit.\r\n\r\n<a name=\"choices\"></a>.choices(key, choices)\r\n----------------------\r\n\r\nLimit valid values for `key` to a predefined set of `choices`, given as an array\r\nor as an individual value.\r\n\r\n```js\r\nvar argv = require('yargs')\r\n  .alias('i', 'ingredient')\r\n  .describe('i', 'choose your sandwich ingredients')\r\n  .choices('i', ['peanut-butter', 'jelly', 'banana', 'pickles'])\r\n  .help('help')\r\n  .argv\r\n```\r\n\r\nIf this method is called multiple times, all enumerated values will be merged\r\ntogether. Choices are generally strings or numbers, and value matching is\r\ncase-sensitive.\r\n\r\nOptionally `.choices()` can take an object that maps multiple keys to their\r\nchoices.\r\n\r\nChoices can also be specified as `choices` in the object given to `option()`.\r\n\r\n```js\r\nvar argv = require('yargs')\r\n  .option('size', {\r\n    alias: 's',\r\n    describe: 'choose a size',\r\n    choices: ['xs', 's', 'm', 'l', 'xl']\r\n  })\r\n  .argv\r\n```\r\n\r\n.command(cmd, desc, [builder], [handler])\r\n-----------------------------------------\r\n.command(cmd, desc, [module])\r\n-----------------------------\r\n.command(module)\r\n----------------\r\n\r\nDocument the commands exposed by your application.\r\n\r\nUse `desc` to provide a description for each command your application accepts (the\r\nvalues stored in `argv._`).  Set `desc` to `false` to create a hidden command.\r\nHidden commands don't show up in the help output and aren't available for\r\ncompletion.\r\n\r\nOptionally, you can provide a `builder` object to give hints about the\r\noptions that your command accepts:\r\n\r\n```js\r\nyargs.command('get', 'make a get HTTP request', {\r\n    url: {\r\n      alias: 'u',\r\n      default: 'http://yargs.js.org/'\r\n    }\r\n  })\r\n  .help()\r\n  .argv\r\n```\r\n\r\n`builder` can also be a function. This function is executed\r\nwith a `yargs` instance, and can be used to provide _advanced_ command specific help:\r\n\r\n```js\r\nyargs.command('get', 'make a get HTTP request', function (yargs) {\r\n    return yargs.option('url', {\r\n      alias: 'u',\r\n      default: 'http://yargs.js.org/'\r\n    })\r\n  })\r\n  .help()\r\n  .argv\r\n```\r\n\r\nYou can also provide a handler function, which will be executed with the\r\nparsed `argv` object:\r\n\r\n```js\r\nyargs\r\n  .command(\r\n    'get',\r\n    'make a get HTTP request',\r\n    function (yargs) {\r\n      return yargs.option('u', {\r\n        alias: 'url',\r\n        describe: 'the URL to make an HTTP request to'\r\n      })\r\n    },\r\n    function (argv) {\r\n      console.log(argv.url)\r\n    }\r\n  )\r\n  .help()\r\n  .argv\r\n```\r\n\r\n### Positional Arguments\r\n\r\nCommands can accept _optional_ and _required_ positional arguments. Required\r\npositional arguments take the form `<foo>`, and optional arguments\r\ntake the form `[bar]`. The parsed positional arguments will be populated in\r\n`argv`:\r\n\r\n```js\r\nyargs.command('get <source> [proxy]', 'make a get HTTP request')\r\n  .help()\r\n  .argv\r\n```\r\n\r\n#### Variadic Positional Arguments\r\n\r\nThe last positional argument can optionally accept an array of\r\nvalues, by using the `..` operator:\r\n\r\n```js\r\nyargs.command('download <url> [files..]', 'download several files')\r\n  .help()\r\n  .argv\r\n```\r\n\r\n### Providing a Command Module\r\n\r\nFor complicated commands you can pull the logic into a module. A module\r\nsimply needs to export:\r\n\r\n* `exports.command`: string that executes this command when given on the command line, may contain positional args\r\n* `exports.describe`: string used as the description for the command in help text, use `false` for a hidden command\r\n* `exports.builder`: object declaring the options the command accepts, or a function accepting and returning a yargs instance\r\n* `exports.handler`: a function which will be passed the parsed argv.\r\n\r\n```js\r\n// my-module.js\r\nexports.command = 'get <source> [proxy]'\r\n\r\nexports.describe = 'make a get HTTP request'\r\n\r\nexports.builder = {\r\n  banana: {\r\n    default: 'cool'\r\n  },\r\n  batman: {\r\n    default: 'sad'\r\n  }\r\n}\r\n\r\nexports.handler = function (argv) {\r\n  // do something with argv.\r\n}\r\n```\r\n\r\nYou then register the module like so:\r\n\r\n```js\r\nyargs.command(require('my-module'))\r\n  .help()\r\n  .argv\r\n```\r\n\r\nOr if the module does not export `command` and `describe` (or if you just want to override them):\r\n\r\n```js\r\nyargs.command('get <source> [proxy]', 'make a get HTTP request', require('my-module'))\r\n  .help()\r\n  .argv\r\n```\r\n\r\n.completion([cmd], [description], [fn]);\r\n----------------------------------------\r\n\r\nEnable bash-completion shortcuts for commands and options.\r\n\r\n`cmd`: When present in `argv._`, will result in the `.bashrc` completion script\r\nbeing outputted. To enable bash completions, concat the generated script to your\r\n`.bashrc` or `.bash_profile`.\r\n\r\n`description`: Provide a description in your usage instructions for the command\r\nthat generates bash completion scripts.\r\n\r\n`fn`: Rather than relying on yargs' default completion functionality, which\r\nshiver me timbers is pretty awesome, you can provide your own completion\r\nmethod.\r\n\r\nIf invoked without parameters, `.completion()` will make `completion` the command to output\r\nthe completion script.\r\n\r\n```js\r\nvar argv = require('yargs')\r\n  .completion('completion', function(current, argv) {\r\n    // 'current' is the current command being completed.\r\n    // 'argv' is the parsed arguments so far.\r\n    // simply return an array of completions.\r\n    return [\r\n      'foo',\r\n      'bar'\r\n    ];\r\n  })\r\n  .argv;\r\n```\r\n\r\nYou can also provide asynchronous completions.\r\n\r\n```js\r\nvar argv = require('yargs')\r\n  .completion('completion', function(current, argv, done) {\r\n    setTimeout(function() {\r\n      done([\r\n        'apple',\r\n        'banana'\r\n      ]);\r\n    }, 500);\r\n  })\r\n  .argv;\r\n```\r\n\r\nBut wait, there's more! You can return an asynchronous promise.\r\n\r\n```js\r\nvar argv = require('yargs')\r\n  .completion('completion', function(current, argv, done) {\r\n    return new Promise(function (resolve, reject) {\r\n      setTimeout(function () {\r\n        resolve(['apple', 'banana'])\r\n      }, 10)\r\n    })\r\n  })\r\n  .argv;\r\n```\r\n\r\n<a name=\"config\"></a>.config([key], [description], [parseFn])\r\n-------------------------------------------------------------\r\n.config(object)\r\n---------------\r\n\r\nTells the parser that if the option specified by `key` is passed in, it\r\nshould be interpreted as a path to a JSON config file. The file is loaded\r\nand parsed, and its properties are set as arguments.\r\n\r\nIf invoked without parameters, `.config()` will make `--config` the option to pass the JSON config file.\r\n\r\nAn optional `description` can be provided to customize the config (`key`) option\r\nin the usage string.\r\n\r\nAn optional `parseFn` can be used to provide a custom parser. The parsing\r\nfunction must be synchronous, and should return an object containing\r\nkey value pairs or an error.\r\n\r\n```js\r\nvar argv = require('yargs')\r\n  .config('settings', function (configPath) {\r\n    return JSON.parse(fs.readFileSync(configPath, 'utf-8'))\r\n  })\r\n  .argv\r\n```\r\n\r\nYou can also pass an explicit configuration `object`, it will be parsed \r\nand its properties will be set as arguments.\r\n             \r\n```js\r\nvar argv = require('yargs')\r\n  .config({foo: 1, bar: 2})\r\n  .argv\r\nconsole.log(argv)\r\n```\r\n \r\n```\r\n$ node test.js\r\n{ _: [],\r\n  foo: 1,\r\n  bar: 2,\r\n  '$0': 'test.js' }\r\n```\r\n\r\n<a name=\"count\"></a>.count(key)\r\n------------\r\n\r\nInterpret `key` as a boolean flag, but set its parsed value to the number of\r\nflag occurrences rather than `true` or `false`. Default value is thus `0`.\r\n\r\n<a name=\"default\"></a>.default(key, value, [description])\r\n---------------------------------------------------------\r\n.defaults(key, value, [description])\r\n------------------------------------\r\n\r\n**Note:** The `.defaults()` alias is deprecated. It will be \r\nremoved in the next major version.\r\n\r\nSet `argv[key]` to `value` if no option was specified in `process.argv`.\r\n\r\nOptionally `.default()` can take an object that maps keys to default values.\r\n\r\nBut wait, there's more! The default value can be a `function` which returns\r\na value. The name of the function will be used in the usage string:\r\n\r\n```js\r\nvar argv = require('yargs')\r\n  .default('random', function randomValue() {\r\n    return Math.random() * 256;\r\n  }).argv;\r\n```\r\n\r\nOptionally, `description` can also be provided and will take precedence over\r\ndisplaying the value in the usage instructions:\r\n\r\n```js\r\n.default('timeout', 60000, '(one-minute)')\r\n```\r\n\r\n<a name=\"demand\"></a>.demand(key, [msg | boolean])\r\n------------------------------\r\n.demand(count, [max], [msg])\r\n------------------------------\r\n\r\nIf `key` is a string, show the usage information and exit if `key` wasn't\r\nspecified in `process.argv`.\r\n\r\nIf `key` is a number, demand at least as many non-option arguments, which show\r\nup in `argv._`. A second number can also optionally be provided, which indicates\r\nthe maximum number of non-option arguments.\r\n\r\nIf `key` is an array, demand each element.\r\n\r\nIf a `msg` string is given, it will be printed when the argument is missing,\r\ninstead of the standard error message. This is especially helpful for the non-option arguments in `argv._`.\r\n\r\nIf a `boolean` value is given, it controls whether the option is demanded;\r\nthis is useful when using `.options()` to specify command line parameters.\r\n\r\nA combination of `.demand(1)` and `.strict()` will allow you to require a user to pass at least one command:\r\n\r\n```js\r\nvar argv = require('yargs')\r\n  .command('install', 'tis a mighty fine package to install')\r\n  .demand(1)\r\n  .strict()\r\n  .argv\r\n```\r\n\r\nSimilarly, you can require a command and arguments at the same time:\r\n\r\n```js\r\nvar argv = require('yargs')\r\n  .command('install', 'tis a mighty fine package to install')\r\n  .demand(1, ['w', 'm'])\r\n  .strict()\r\n  .argv\r\n```\r\n\r\n<a name=\"describe\"></a>.describe(key, desc)\r\n--------------------\r\n\r\nDescribe a `key` for the generated usage information.\r\n\r\nOptionally `.describe()` can take an object that maps keys to descriptions.\r\n\r\n.detectLocale(boolean)\r\n-----------\r\n\r\nShould yargs attempt to detect the os' locale? Defaults to `true`.\r\n\r\n.env([prefix])\r\n--------------\r\n\r\nTell yargs to parse environment variables matching the given prefix and apply\r\nthem to argv as though they were command line arguments.\r\n\r\nUse the \"__\" separator in the environment variable to indicate nested options.\r\n(e.g. prefix_nested__foo => nested.foo)\r\n\r\nIf this method is called with no argument or with an empty string or with `true`,\r\nthen all env vars will be applied to argv.\r\n\r\nProgram arguments are defined in this order of precedence:\r\n\r\n1. Command line args\r\n2. Config file\r\n3. Env var\r\n4. Configured defaults\r\n\r\n```js\r\nvar argv = require('yargs')\r\n  .env('MY_PROGRAM')\r\n  .option('f', {\r\n    alias: 'fruit-thing',\r\n    default: 'apple'\r\n  })\r\n  .argv\r\nconsole.log(argv)\r\n```\r\n\r\n```\r\n$ node fruity.js\r\n{ _: [],\r\n  f: 'apple',\r\n  'fruit-thing': 'apple',\r\n  fruitThing: 'apple',\r\n  '$0': 'fruity.js' }\r\n```\r\n\r\n```\r\n$ MY_PROGRAM_FRUIT_THING=banana node fruity.js\r\n{ _: [],\r\n  fruitThing: 'banana',\r\n  f: 'banana',\r\n  'fruit-thing': 'banana',\r\n  '$0': 'fruity.js' }\r\n```\r\n\r\n```\r\n$ MY_PROGRAM_FRUIT_THING=banana node fruity.js -f cat\r\n{ _: [],\r\n  f: 'cat',\r\n  'fruit-thing': 'cat',\r\n  fruitThing: 'cat',\r\n  '$0': 'fruity.js' }\r\n```\r\n\r\nEnv var parsing is disabled by default, but you can also explicitly disable it\r\nby calling `.env(false)`, e.g. if you need to undo previous configuration.\r\n\r\n.epilog(str)\r\n------------\r\n.epilogue(str)\r\n--------------\r\n\r\nA message to print at the end of the usage instructions, e.g.\r\n\r\n```js\r\nvar argv = require('yargs')\r\n  .epilogue('for more information, find our manual at http://example.com');\r\n```\r\n\r\n.example(cmd, desc)\r\n-------------------\r\n\r\nGive some example invocations of your program. Inside `cmd`, the string\r\n`$0` will get interpolated to the current script name or node command for the\r\npresent script similar to how `$0` works in bash or perl.\r\nExamples will be printed out as part of the help message.\r\n\r\n.exitProcess(enable)\r\n----------------------------------\r\n\r\nBy default, yargs exits the process when the user passes a help flag, uses the\r\n`.version` functionality, or when validation fails. Calling\r\n`.exitProcess(false)` disables this behavior, enabling further actions after\r\nyargs have been validated.\r\n\r\n.fail(fn)\r\n---------\r\n\r\nMethod to execute when a failure occurs, rather than printing the failure message.\r\n\r\n`fn` is called with the failure message that would have been printed and the\r\n`Error` instance originally thrown, if any.\r\n\r\n```js\r\nvar argv = require('yargs')\r\n  .fail(function (msg, err) {\r\n    if (err) throw err // preserve stack\r\n    console.error('You broke it!')\r\n    console.error(msg)\r\n    process.exit(1)\r\n  })\r\n  .argv\r\n```\r\n\r\n.getCompletion(args, done);\r\n---------------------------\r\n\r\nAllows to programmatically get completion choices for any line.\r\n\r\n`args`: An array of the words in the command line to complete.\r\n\r\n`done`: The callback to be called with the resulting completions.\r\n\r\nFor example:\r\n\r\n```js\r\nrequire('yargs')\r\n  .option('foobar', {})\r\n  .option('foobaz', {})\r\n  .completion()\r\n  .getCompletion(['./test.js', '--foo'], function (completions) {\r\n    console.log(completions)\r\n  })\r\n```\r\n\r\nOutputs the same completion choices as `./test.js --foo`<kbd>TAB</kbd>: `--foobar` and `--foobaz`\r\n\r\n<a name=\"global\"></a>.global(globals)\r\n------------\r\n\r\nIndicate that an option (or group of options) should not be reset when a command\r\nis executed, as an example:\r\n\r\n```js\r\nvar argv = require('yargs')\r\n  .option('a', {\r\n    alias: 'all',\r\n    default: true\r\n  })\r\n  .option('n', {\r\n    alias: 'none',\r\n    default: true\r\n  })\r\n  .command('foo', 'foo command', function (yargs) {\r\n    return yargs.option('b', {\r\n      alias: 'bar'\r\n    })\r\n  })\r\n  .help('help')\r\n  .global('a')\r\n  .argv\r\n```\r\n\r\nIf the `foo` command is executed the `all` option will remain, but the `none`\r\noption will have been eliminated.\r\n\r\n`help`, `version`, and `completion` options default to being global.\r\n\r\n<a name=\"group\"></a>.group(key(s), groupName)\r\n--------------------\r\n\r\nGiven a key, or an array of keys, places options under an alternative heading\r\nwhen displaying usage instructions, e.g.,\r\n\r\n```js\r\nvar yargs = require('yargs')(['--help'])\r\n  .help()\r\n  .group('batman', 'Heroes:')\r\n  .describe('batman', \"world's greatest detective\")\r\n  .wrap(null)\r\n  .argv\r\n```\r\n***\r\n    Heroes:\r\n      --batman  world's greatest detective\r\n\r\n    Options:\r\n      --help  Show help  [boolean]\r\n\r\n.help([option, [description]])\r\n------------------------------\r\n\r\nAdd an option (e.g. `--help`) that displays the usage string and exits the\r\nprocess. If present, the `description` parameter customizes the description of\r\nthe help option in the usage string.\r\n\r\nIf invoked without parameters, `.help()` will make `--help` the option to trigger\r\nhelp output.\r\n\r\nExample:\r\n\r\n```js\r\nvar yargs = require(\"yargs\")(['--help'])\r\n  .usage(\"$0 -operand1 number -operand2 number -operation [add|subtract]\")\r\n  .help()\r\n  .argv\r\n```\r\n\r\nLater on, `argv` can be retrieved with `yargs.argv`.\r\n\r\n.implies(x, y)\r\n--------------\r\n\r\nGiven the key `x` is set, it is required that the key `y` is set.\r\n\r\nOptionally `.implies()` can accept an object specifying multiple implications.\r\n\r\n.locale()\r\n---------\r\n\r\nReturn the locale that yargs is currently using.\r\n\r\nBy default, yargs will auto-detect the operating system's locale so that\r\nyargs-generated help content will display in the user's language.\r\n\r\nTo override this behavior with a static locale, pass the desired locale as a\r\nstring to this method (see below).\r\n\r\n.locale(locale)\r\n---------------\r\n\r\nOverride the auto-detected locale from the user's operating system with a static\r\nlocale. Note that the OS locale can be modified by setting/exporting the `LC_ALL`\r\nenvironment variable.\r\n\r\n```js\r\nvar argv = require('yargs')\r\n  .usage('./$0 - follow ye instructions true')\r\n  .option('option', {\r\n    alias: 'o',\r\n    describe: \"'tis a mighty fine option\",\r\n    demand: true\r\n  })\r\n  .command('run', \"Arrr, ya best be knowin' what yer doin'\")\r\n  .example('$0 run foo', \"shiver me timbers, here's an example for ye\")\r\n  .help('help')\r\n  .wrap(70)\r\n  .locale('pirate')\r\n  .argv\r\n```\r\n\r\n***\r\n\r\n```shell\r\n./test.js - follow ye instructions true\r\n\r\nChoose yer command:\r\n  run  Arrr, ya best be knowin' what yer doin'\r\n\r\nOptions for me hearties!\r\n  --option, -o  'tis a mighty fine option               [requi-yar-ed]\r\n  --help        Parlay this here code of conduct             [boolean]\r\n\r\nEx. marks the spot:\r\n  test.js run foo  shiver me timbers, here's an example for ye\r\n\r\nYe be havin' to set the followin' argument land lubber: option\r\n```\r\n\r\nLocales currently supported:\r\n\r\n* **de:** German.\r\n* **en:** American English.\r\n* **es:** Spanish.\r\n* **fr:** French.\r\n* **id:** Indonesian.\r\n* **it:** Italian.\r\n* **ja:** Japanese.\r\n* **ko:** Korean.\r\n* **nb:** Norwegian Bokm√•l.\r\n* **pirate:** American Pirate.\r\n* **pl:** Polish.\r\n* **pt:** Portuguese.\r\n* **pt_BR:** Brazilian Portuguese.\r\n* **tr:** Turkish.\r\n* **zh:** Chinese.\r\n\r\nTo submit a new translation for yargs:\r\n\r\n1. use `./locales/en.json` as a starting point.\r\n2. submit a pull request with the new locale file.\r\n\r\n*The [Microsoft Terminology Search](http://www.microsoft.com/Language/en-US/Search.aspx) can be useful for finding the correct terminology in your locale.*\r\n\r\n<a name=\"nargs\"></a>.nargs(key, count)\r\n-----------\r\n\r\nThe number of arguments that should be consumed after a key. This can be a\r\nuseful hint to prevent parsing ambiguity. For example:\r\n\r\n```js\r\nvar argv = require('yargs')\r\n  .nargs('token', 1)\r\n  .parse(['--token', '-my-token']);\r\n```\r\n\r\nparses as:\r\n\r\n`{ _: [], token: '-my-token', '$0': 'node test' }`\r\n\r\nOptionally `.nargs()` can take an object of `key`/`narg` pairs.\r\n\r\n<a name=\"normalize\"></a>.normalize(key)\r\n---------------\r\n\r\nThe key provided represents a path and should have `path.normalize()` applied.\r\n\r\n<a name=\"number\"></a>.number(key)\r\n------------\r\n\r\nTell the parser to always interpret `key` as a number.\r\n\r\nIf `key` is an array, all elements will be parsed as numbers.\r\n\r\nIf the option is given on the command line without a value, `argv` will be\r\npopulated with `undefined`.\r\n\r\nIf the value given on the command line cannot be parsed as a number, `argv` will\r\nbe populated with `NaN`.\r\n\r\nNote that decimals, hexadecimals, and scientific notation are all accepted.\r\n\r\n```js\r\nvar argv = require('yargs')\r\n  .number('n')\r\n  .number(['width', 'height'])\r\n  .argv\r\n```\r\n\r\n.option(key, opt)\r\n-----------------\r\n.options(key, opt)\r\n------------------\r\n\r\nInstead of chaining together `.alias().demand().default().describe().string()`, you can specify\r\nkeys in `opt` for each of the chainable methods.\r\n\r\nFor example:\r\n\r\n````javascript\r\nvar argv = require('yargs')\r\n    .option('f', {\r\n        alias: 'file',\r\n        demand: true,\r\n        default: '/etc/passwd',\r\n        describe: 'x marks the spot',\r\n        type: 'string'\r\n    })\r\n    .argv\r\n;\r\n````\r\n\r\nis the same as\r\n\r\n````javascript\r\nvar argv = require('yargs')\r\n    .alias('f', 'file')\r\n    .demand('f')\r\n    .default('f', '/etc/passwd')\r\n    .describe('f', 'x marks the spot')\r\n    .string('f')\r\n    .argv\r\n;\r\n````\r\n\r\nOptionally `.options()` can take an object that maps keys to `opt` parameters.\r\n\r\n````javascript\r\nvar argv = require('yargs')\r\n    .options({\r\n      'f': {\r\n        alias: 'file',\r\n        demand: true,\r\n        default: '/etc/passwd',\r\n        describe: 'x marks the spot',\r\n        type: 'string'\r\n      }\r\n    })\r\n    .argv\r\n;\r\n````\r\n\r\nValid `opt` keys include:\r\n\r\n- `alias`: string or array of strings, alias(es) for the canonical option key, see [`alias()`](#alias)\r\n- `array`: boolean, interpret option as an array, see [`array()`](#array)\r\n- `boolean`: boolean, interpret option as a boolean flag, see [`boolean()`](#boolean)\r\n- `choices`: value or array of values, limit valid option arguments to a predefined set, see [`choices()`](#choices)\r\n- `config`: boolean, interpret option as a path to a JSON config file, see [`config()`](#config)\r\n- `configParser`: function, provide a custom config parsing function, see [`config()`](#config)\r\n- `count`: boolean, interpret option as a count of boolean flags, see [`count()`](#count)\r\n- `default`: value, set a default value for the option, see [`default()`](#default)\r\n- `defaultDescription`: string, use this description for the default value in help content, see [`default()`](#default)\r\n- `demand`/`require`/`required`: boolean or string, demand the option be given, with optional error message, see [`demand()`](#demand)\r\n- `desc`/`describe`/`description`: string, the option description for help content, see [`describe()`](#describe)\r\n- `global`: boolean, indicate that this key should not be [reset](#reset) when a command is invoked, see [`global()`](#global)\r\n- `group`: string, when displaying usage instructions place the option under an alternative group heading, see [`group()`](#group)\r\n- `nargs`: number, specify how many arguments should be consumed for the option, see [`nargs()`](#nargs)\r\n- `normalize`: boolean, apply `path.normalize()` to the option, see [`normalize()`](#normalize)\r\n- `number`: boolean, interpret option as a number, [`number()`](#number)\r\n- `requiresArg`: boolean, require the option be specified with a value, see [`requiresArg()`](#requiresArg)\r\n- `skipValidation`: boolean, skips validation if the option is present, see [`skipValidation()`](#skipValidation)\r\n- `string`: boolean, interpret option as a string, see [`string()`](#string)\r\n- `type`: one of the following strings\r\n    - `'array'`: synonymous for `array: true`, see [`array()`](#array)\r\n    - `'boolean'`: synonymous for `boolean: true`, see [`boolean()`](#boolean)\r\n    - `'count'`: synonymous for `count: true`, see [`count()`](#count)\r\n    - `'number'`: synonymous for `number: true`, see [`number()`](#number)\r\n    - `'string'`: synonymous for `string: true`, see [`string()`](#string)\r\n\r\n.parse(args)\r\n------------\r\n\r\nParse `args` instead of `process.argv`. Returns the `argv` object.\r\n\r\n`args` may either be a pre-processed argv array, or a raw argument string.\r\n\r\n.pkgConf(key, [cwd])\r\n------------\r\n\r\nSimilar to [`config()`](#config), indicates that yargs should interpret the object from the specified key in package.json\r\nas a configuration object.\r\n\r\n`cwd` can optionally be provided, the package.json will be read\r\nfrom this location.\r\n\r\n.require(key, [msg | boolean])\r\n------------------------------\r\n.required(key, [msg | boolean])\r\n------------------------------\r\n\r\nAn alias for [`demand()`](#demand). See docs there.\r\n\r\n<a name=\"requiresArg\"></a>.requiresArg(key)\r\n-----------------\r\n\r\nSpecifies either a single option key (string), or an array of options that\r\nmust be followed by option values. If any option value is missing, show the\r\nusage information and exit.\r\n\r\nThe default behavior is to set the value of any key not followed by an\r\noption value to `true`.\r\n\r\n<a name=\"reset\"></a>.reset()\r\n--------\r\n\r\nReset the argument object built up so far. This is useful for\r\ncreating nested command line interfaces. Use [global](#global)\r\nto specify keys that should not be reset.\r\n\r\n```js\r\nvar yargs = require('yargs')\r\n  .usage('$0 command')\r\n  .command('hello', 'hello command')\r\n  .command('world', 'world command')\r\n  .demand(1, 'must provide a valid command'),\r\n  argv = yargs.argv,\r\n  command = argv._[0];\r\n\r\nif (command === 'hello') {\r\n  yargs.reset()\r\n    .usage('$0 hello')\r\n    .help('h')\r\n    .example('$0 hello', 'print the hello message!')\r\n    .argv\r\n\r\n  console.log('hello!');\r\n} else if (command === 'world'){\r\n  yargs.reset()\r\n    .usage('$0 world')\r\n    .help('h')\r\n    .example('$0 world', 'print the world message!')\r\n    .argv\r\n\r\n  console.log('world!');\r\n} else {\r\n  yargs.showHelp();\r\n}\r\n```\r\n\r\n.showCompletionScript()\r\n----------------------\r\n\r\nGenerate a bash completion script. Users of your application can install this\r\nscript in their `.bashrc`, and yargs will provide completion shortcuts for\r\ncommands and options.\r\n\r\n.showHelp(consoleLevel='error')\r\n---------------------------\r\n\r\nPrint the usage data using the [`console`](https://nodejs.org/api/console.html) function `consoleLevel` for printing.\r\n\r\nExample:\r\n\r\n```js\r\nvar yargs = require(\"yargs\")\r\n  .usage(\"$0 -operand1 number -operand2 number -operation [add|subtract]\");\r\nyargs.showHelp(); //prints to stderr using console.error()\r\n```\r\n\r\nOr, to print the usage data to `stdout` instead, you can specify the use of `console.log`:\r\n\r\n```js\r\nyargs.showHelp(\"log\"); //prints to stdout using console.log()\r\n```\r\n\r\nLater on, `argv` can be retrieved with `yargs.argv`.\r\n\r\n.showHelpOnFail(enable, [message])\r\n----------------------------------\r\n\r\nBy default, yargs outputs a usage string if any error is detected. Use the\r\n`.showHelpOnFail()` method to customize this behavior. If `enable` is `false`,\r\nthe usage string is not output. If the `message` parameter is present, this\r\nmessage is output after the error message.\r\n\r\nline_count.js:\r\n\r\n````javascript\r\n#!/usr/bin/env node\r\nvar argv = require('yargs')\r\n    .usage('Count the lines in a file.\\nUsage: $0 -f <file>')\r\n    .demand('f')\r\n    .alias('f', 'file')\r\n    .describe('f', 'Load a file')\r\n    .string('f')\r\n    .showHelpOnFail(false, 'Specify --help for available options')\r\n    .help('help')\r\n    .argv;\r\n\r\n// etc.\r\n````\r\n\r\n***\r\n\r\n```\r\n$ node line_count.js\r\nMissing argument value: f\r\n\r\nSpecify --help for available options\r\n```\r\n\r\n<a name=\"skipValidation\"></a>.skipValidation(key)\r\n-----------------\r\n\r\nSpecifies either a single option key (string), or an array of options.\r\nIf any of the options is present, yargs validation is skipped.\r\n\r\n.strict()\r\n---------\r\n\r\nAny command-line argument given that is not demanded, or does not have a\r\ncorresponding description, will be reported as an error.\r\n\r\n<a name=\"string\"></a>.string(key)\r\n------------\r\n\r\nTell the parser logic not to interpret `key` as a number or boolean.\r\nThis can be useful if you need to preserve leading zeros in an input.\r\n\r\nIf `key` is an array, interpret all the elements as strings.\r\n\r\n`.string('_')` will result in non-hyphenated arguments being interpreted as strings,\r\nregardless of whether they resemble numbers.\r\n\r\n.updateLocale(obj)\r\n------------------\r\n.updateStrings(obj)\r\n------------------\r\n\r\nOverride the default strings used by yargs with the key/value\r\npairs provided in `obj`:\r\n\r\n```js\r\nvar argv = require('yargs')\r\n  .command('run', 'the run command')\r\n  .help('help')\r\n  .updateStrings({\r\n    'Commands:': 'My Commands -->\\n'\r\n  })\r\n  .wrap(null)\r\n  .argv\r\n```\r\n\r\n***\r\n\r\n```shell\r\nMy Commands -->\r\n\r\n  run  the run command\r\n\r\nOptions:\r\n  --help  Show help  [boolean]\r\n```\r\n\r\nIf you explicitly specify a `locale()`, you should do so *before* calling\r\n`updateStrings()`.\r\n\r\n.usage(message, [opts])\r\n---------------------\r\n\r\nSet a usage message to show which commands to use. Inside `message`, the string\r\n`$0` will get interpolated to the current script name or node command for the\r\npresent script similar to how `$0` works in bash or perl.\r\n\r\n`opts` is optional and acts like calling `.options(opts)`.\r\n\r\n.version([option], [description], [version])\r\n----------------------------------------\r\n\r\nAdd an option (e.g. `--version`) that displays the version number (given by the\r\n`version` parameter) and exits the process.\r\n\r\nIf no arguments are passed to `version` (`.version()`), yargs will parse the `package.json`\r\nof your module and use its `version` value. The default value of `option` is `--version`.\r\n\r\nYou can provide a `function` for version, rather than a string.\r\nThis is useful if you want to use a version stored in a location other than package.json:\r\n\r\n```js\r\nvar argv = require('yargs')\r\n  .version(function() {\r\n    return require('../lib/version').version;\r\n  })\r\n  .argv;\r\n```\r\n\r\n.wrap(columns)\r\n--------------\r\n\r\nFormat usage output to wrap at `columns` many columns.\r\n\r\nBy default wrap will be set to `Math.min(80, windowWidth)`. Use `.wrap(null)` to\r\nspecify no column limit (no right-align). Use `.wrap(yargs.terminalWidth())` to\r\nmaximize the width of yargs' usage instructions.\r\n\r\nparsing tricks\r\n==============\r\n\r\nstop parsing\r\n------------\r\n\r\nUse `--` to stop parsing flags and stuff the remainder into `argv._`.\r\n\r\n    $ node examples/reflect.js -a 1 -b 2 -- -c 3 -d 4\r\n    { _: [ '-c', '3', '-d', '4' ],\r\n      a: 1,\r\n      b: 2,\r\n      '$0': 'examples/reflect.js' }\r\n\r\nnegate fields\r\n-------------\r\n\r\nIf you want to explicitly set a field to false instead of just leaving it\r\nundefined or to override a default you can do `--no-key`.\r\n\r\n    $ node examples/reflect.js -a --no-b\r\n    { _: [], a: true, b: false, '$0': 'examples/reflect.js' }\r\n\r\nnumbers\r\n-------\r\n\r\nEvery argument that looks like a number (`!isNaN(Number(arg))`) is converted to\r\none. This way you can just `net.createConnection(argv.port)` and you can add\r\nnumbers out of `argv` with `+` without having that mean concatenation,\r\nwhich is super frustrating.\r\n\r\nduplicates\r\n----------\r\n\r\nIf you specify a flag multiple times it will get turned into an array containing\r\nall the values in order.\r\n\r\n    $ node examples/reflect.js -x 5 -x 8 -x 0\r\n    { _: [], x: [ 5, 8, 0 ], '$0': 'examples/reflect.js' }\r\n\r\ndot notation\r\n------------\r\n\r\nWhen you use dots (`.`s) in argument names, an implicit object path is assumed.\r\nThis lets you organize arguments into nested objects.\r\n\r\n    $ node examples/reflect.js --foo.bar.baz=33 --foo.quux=5\r\n    { _: [],\r\n      foo: { bar: { baz: 33 }, quux: 5 },\r\n      '$0': 'examples/reflect.js' }\r\n\r\nshort numbers\r\n-------------\r\n\r\nShort numeric `-n5` style arguments work too:\r\n\r\n    $ node examples/reflect.js -n123 -m456\r\n    { _: [], n: 123, m: 456, '$0': 'examples/reflect.js' }\r\n\r\ninstallation\r\n============\r\n\r\nWith [npm](https://github.com/npm/npm), just do:\r\n\r\n    npm install yargs\r\n\r\nor clone this project on github:\r\n\r\n    git clone http://github.com/yargs/yargs.git\r\n\r\nTo run the tests with npm, just do:\r\n\r\n    npm test\r\n\r\nconfiguration\r\n=============\r\n\r\nUsing the `yargs` stanza in your `package.json` you can turn on and off\r\nsome of yargs' parsing features:\r\n\r\n```json\r\n{\r\n  \"yargs\": {\r\n    \"short-option-groups\": true,\r\n    \"camel-case-expansion\": true,\r\n    \"dot-notation\": true,\r\n    \"parse-numbers\": true,\r\n    \"boolean-negation\": true\r\n  }\r\n}\r\n```\r\n\r\nSee the [yargs-parser](https://github.com/yargs/yargs-parser#configuration) module\r\nfor detailed documentation of this feature.\r\n\r\ninspired by\r\n===========\r\n\r\nThis module is loosely inspired by Perl's\r\n[Getopt::Casual](http://search.cpan.org/~photo/Getopt-Casual-0.13.1/Casual.pm).\r\n\r\n[travis-url]: https://travis-ci.org/yargs/yargs\r\n[travis-image]: https://img.shields.io/travis/yargs/yargs.svg\r\n[gemnasium-url]: https://gemnasium.com/yargs/yargs\r\n[gemnasium-image]: https://img.shields.io/gemnasium/yargs/yargs.svg\r\n[coveralls-url]: https://coveralls.io/github/yargs/yargs\r\n[coveralls-image]: https://img.shields.io/coveralls/yargs/yargs.svg\r\n[npm-url]: https://www.npmjs.com/package/yargs\r\n[npm-image]: https://img.shields.io/npm/v/yargs.svg\r\n[windows-url]: https://ci.appveyor.com/project/bcoe/yargs\r\n[windows-image]: https://img.shields.io/appveyor/ci/bcoe/yargs/master.svg?label=Windows%20Tests\r\n[standard-image]: https://img.shields.io/badge/code%20style-standard-brightgreen.svg\r\n[standard-url]: http://standardjs.com/\r\n[standard-version-image]: https://img.shields.io/badge/release-standard%20version-brightgreen.svg\r\n[standard-version-url]: https://github.com/conventional-changelog/standard-version\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/yargs/yargs.git"
  },
  "scripts": {
    "coverage": "nyc report --reporter=text-lcov | coveralls",
    "pretest": "standard",
    "test": "nyc --cache mocha --require ./test/before.js --timeout=8000 --check-leaks",
    "version": "standard-version"
  },
  "standard": {
    "ignore": [
      "**/example/**"
    ]
  },
  "version": "4.7.1"
}
